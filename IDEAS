This is just a file for future ideas, features, etc

So far the plugins have worked quite well for the OmniBot.main() features. But I'm thinking some 
standards are in order. First of all there should be initial and ending plugins that either
hook into parts of the end of the Category/module they are enhancing or the beginning. In this
way the return values can be manipulated OR the initial settings can be modified. We're considering
to extend this to classes but I'm looking into this as python isn't my first language. So essentially
what we have seen for main() so far is:
    PLUGINS_OMNIBOT_MAIN[0:x].main() functions
    but then we should also see something like
    PLUGINS_OMNIBOT_MAIN[0:x].end() functions checked upon? 

I'm not sure this is my first time extending plugin functionality to a program but we'll see how it goes


Source code / program structure:
    *OmniLib/Comm - will store all connection methods (IRC/AIM/HTTP/Etc) - Each Comm/*/ will contain the initial
    connection methods as well as 
    *OmniLib/Auth - will store all user Authentication shits, it provides a common interface so that protocols dont
    have to worry about the details of matters like loading keys and such. Ideall the Config module should interface
    with the Auth module upon startup and add the required users/keys/etc
    *OmniLib/plugins - This is self explanatory and has been described to a little length above, this is a work
    in progress..
    *OmniLib/Config - This is responsible for handling all things related to configuration of the program, this
    includes loading from configuration files, loading from command line, and perhaps distrubuted/remote configging
    (for large nets of bots)
    
Perhaps I am getting too far ahead of myself... for now the TODO is pointing for a functional IRC portion, we'll work
on that then work our way back thru

Ideas for auth:
    keyexchange can take place over email. for example: '!authorize --request_key' would email a key back to a
    pre-specified account in the config file then give it a short timeout value for the end user to !authorize <key>
    optionally only a portion of the key should be sent while the rest is used for encryption. maybe the first 4 bytes?
    so we've got this model for auth:
	Bot: starts->reads config file->adds email to nick/user pairing->waits for !authorize
	User: sends-PM->!authorize --request_key
	Bot: checks against nick/host-> generates random key -> gives it a timeout value-> sends it to email addr
	User: sends-PM->!authorize <first-4bytes of key>
	Bot: adds nick/host to authorized list
    Also we may want multiple authorization levels: Admin, Power, Friend, Etc.
    
    Another note for security: I want each user to have a private key for the keygen in addition to the auth library checking 
    their user string. eventually we can progress on to having individual send/recv wrappers for each user that handle with
    encryption going both ways. Each user will have their own key. the key exchange will most likely also happen over email
    at the time of the keygen